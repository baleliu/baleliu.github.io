(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{106:function(n,e,t){"use strict";t.r(e),t.d(e,"default",function(){return f});var o=t(13),a=t.n(o),c=t(14),r=t.n(c),s=t(15),i=t.n(s),m=t(16),l=t.n(m),d=t(17),u=t.n(d),k=t(0),p=t.n(k),b=t(33),g=t(73),f=function(n){function e(){return a()(this,e),i()(this,l()(e).apply(this,arguments))}return u()(e,n),r()(e,[{key:"render",value:function(){return p.a.createElement("div",null,p.a.createElement(b.a,{src:g}))}}]),e}(p.a.Component)},107:function(n,e,t){"use strict";t.r(e),t.d(e,"default",function(){return f});var o=t(13),a=t.n(o),c=t(14),r=t.n(c),s=t(15),i=t.n(s),m=t(16),l=t.n(m),d=t(17),u=t.n(d),k=t(0),p=t.n(k),b=t(33),g=t(74),f=function(n){function e(){return a()(this,e),i()(this,l()(e).apply(this,arguments))}return u()(e,n),r()(e,[{key:"render",value:function(){return p.a.createElement("div",null,p.a.createElement(b.a,{src:g}))}}]),e}(p.a.Component)},33:function(n,e,t){"use strict";var o=t(13),a=t.n(o),c=t(14),r=t.n(c),s=t(15),i=t.n(s),m=t(16),l=t.n(m),d=t(17),u=t.n(d),k=t(0),p=t.n(k),b=t(65),g=t.n(b),f=function(n){function e(){return a()(this,e),i()(this,l()(e).apply(this,arguments))}return u()(e,n),r()(e,[{key:"componentDidMount",value:function(){}},{key:"render",value:function(){return p.a.createElement("div",null,p.a.createElement(g.a,{source:this.props.src}))}}]),e}(p.a.Component);f.defaultProps={src:"nothing"},e.a=f},73:function(n,e){n.exports='# 记一次后端Tomcat多环境Docker改造\n\n\n## 背景\n\n> 项目比较小，开发阶段使用云服务器，只有dev环境，当时没有什么任何不适应的情况，项目采用`jenkins+tomcat+nginx`部署\n> 但是！\n> 项目进入 `uat阶段`-`>pro阶段`的时候，问题来了，环境变多了（开发进入后期，云服务的环境也迁入到机房的物理机），但是配置也跟着复杂了起来，这时候我想到了docker（这不是最适合`docker`的情景，但是用`docker`之后很爽）\n> 一不做而不休，撸起袖子打开iterm就把所有环境穿上docker的新衣裳\n\n## 思路\n\n- step1:安装docker\n- step2:将所有后端tomcat都替换成docker-tomcat\n- step3:修改后端jenkins配置\n\n> 这里考虑过把 jenkins也放入docker，把数据库也放入docker，redis也放入docker\n> 1.出于稳定性考虑，数据库服务器已经部署完成，因此不改造db\n> 2.目前jenkins控制docker镜像，因此jenkins放入docker个人感觉必要性不大，因此jenkins使用原本jenkins\n\n## 行动\n\n### 安装Docker\n> docker 安装啥的这里我不多墨迹，满大街都是文档\n\n```\n// todo docker 安装专题（waiting。。。）\n```\n\n```\n// 清理\nyum remove docker*\n```\n```\n// 环境\nyum install -y yum-utils device-mapper-persistent-data lvm2\n```\n\n```\n// 安装\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\nyum -y install docker-ce\n```\n```\n// 查看\ndocker version\n```\n![23777d78db86e54c89c730301b095bda.png](static/img1.jpg)\n\n> `ok` docker 准备好了\n\n\n### 下载Tomcat镜像&准备动作\n\n> 接下来我们把docker加工成我们想要的内容，有心的同学可以自己制作`docker file` 我这里就偷懒使用官方镜像了\n\n```\n// 查看服务器镜像，选择人数最多的就可以 或者去官网查询需要版本\ndocker search tomcat\n// `:`后为版本号，默认不写而`lasted`\n// 这里我使用tomcat9+jre8版本，详情见docker官网\ndocker pull tomcat:9.0.14-jre8\n```\n\n当前环境如下：\n\n> `dev` 日志重要性不大，日志输出多，频繁重启\n> `uat`&`pro`日志很重要，并且需要将日志记录在案，偶尔需要重启\n\n因此采取如下方案：\n> 1.所有环境使用volumes挂载公共路径\n> 2.所有环境使用volumes挂载webapp目录方便jenkins自动部署\n> 3.`uat`&`pro`环境使用volumes持久化存储logs目录下日志\n> 使用配置容器将上述内容配置起来（并不需要启动容器，仅仅提供配置）\n> 4.环境略多，将上述内容编写shell脚本方便使用\n\n```\n#!/bin/sh\nBASE="$0"\n\nENV="$1"\n\n# 简单校验 参数传入\nif [ ! $ENV ] ;then\n    echo "[$BASE ENV] ENV not empty";\n    exit 1;\nelse\n    echo "<-BEGIN->"\nfi\n# dev 环境\nif [$ENV = "dev"] ; then\ndocker create --name conf-tomcat-$ENV \\\n-v /home/tomcat/$ENV/elastic:/usr/local/shareDir \\\n-v /home/tomcat/$ENV/conf:/usr/local/tomcat/conf \\\n-v /home/tomcat/$ENV/webapp:/usr/local/tomcat/webapps \\\ntomcat\nelse\n# 其他环境\ndocker create --name conf-tomcat-$ENV \\\n-v /home/tomcat/$ENV/elastic:/usr/local/shareDir \\\n-v /home/tomcat/$ENV/conf:/usr/local/tomcat/conf \\\n-v /home/tomcat/$ENV/webapp:/usr/local/tomcat/webapps \\\n-v /home/tomcat/$ENV/logs:/usr/local/tomcat/logs \\\ntomcat\nfi\n\necho "<-END->"\n```\n\n```\n// `ok` 准备完成->运行脚本->查看配置情况\n// 记得`-a` 不加参数看不到未启动容器（未启用+异常退出）\ndocker ps -a\n\n// 记得给文件夹授予操作权限\n// 偷懒可以 chown -R 777 文件夹/\n```\n\n不废话，容器运行起来！：\n```\n// 运行tomcat容器\n// 继承对应配置\n// 映射宿主机器端口\n// 直接运行\n// 容器重命名\ndocker run -itd -h 8080:8080 --volumes-from conf-dev --name tomcat-uat tomcat:9.0.14-jre8\n```\n\n```\n// 瞄一眼容器启动情况（没错很稳！）\ndocker ps\n```\n> 到这里docker容器准备已经完成，就等着jenkins使用呢！\n\n\n### Jenkins 配置\n> jenkins 安装也是满大街都是，可以压缩包，可以直接安装，也可以扔到docker里，反正你高兴就行。\n```\n// todo 很详细的jenkins安装 （waiting。。。）\n```\n\n```\n// 把jenkins用户加到docker分组中，让jenkins拥有操作cocker权限\n// 这步无限重要\nusermod -a docker jenkins\n```\n\n> 不管三七二十我们先把jenkins创建一个（假装是一个，其他的都是以后复制的）\n> 配置jenkins\n> 这里需要注意`name=`后面需要写正则表达式，如果不加`^`那么会把我的`配置容器tomcat-env-conf`一起启动起来，虽然没影响，但是浪费资源，而且，如果不小心把其他测试容器弄起来，很吓人的。\n```\n# 进入打包目录，这里我叫`core`小伙伴可以根据`pom`的`finalName`来自己改动\ncd core\nENV=dev\n/usr/local/maven/bin/mvn clean package -P$ENV\ncd target\nrm -rf /home/tomcat/$ENV/webapp/core-$ENV.war\nmv core.war /home/tomcat/$ENV/webapp/core-$ENV.war\n# 喵一眼镜像情况，方便查看\ndocker ps -a\n# 重启我们需要的镜像\ndocker restart `docker ps -aq   --filter name="^tomcat-$ENV\\$"`\n```\n\n> ok 完成配置，启动一下喵一眼，并且把其他环境配置起来，复制工程即可\n\n### 前端改造\n\n```\n// todo 前端多环境，下一次改造一波。\n```\n\n## 总结\n\n> docker 准备的期间略显麻烦，但是当来到jenkins的步骤的时候，就已经可以明显的体会到docker的方便，不仅配置少了很多，并且管用用户的处理也更加方便（之前jenkins要处理tomcat那可是要不少麻烦事情，可能有偷懒的小伙伴直接改成root，但是安全隐患又成一个问题）\n\n'},74:function(n,e){n.exports="# 单机部署k8s并部署tomcat服务\n\n## 目录\n\n* [基本安装](#基本安装)\n* [k8s集群初始化](k8s集群初始化)\n* [安装过程中遇到的问题](安装过程中遇到的问题)\n* [安装完成后的配置](安装完成后的配置)\n* [配置tomcat RC](配置tomcatRC)\n* [配置tomcat service](配置tomcatservice)\n* [查看战果](查看战果)\n* [总结](总结)\n\n## 开始\n\n### 环境\n\n基本配置\n\n| 内容 | 参数 |\n| --- | --- |\n| 操作系统 | centos7 |\n| 机器环境 | VMware虚拟机（mac） |\n| 部署目标 | tomcat任意版本 |\n\n虚拟机配置\n\n| 内容 | 参数 |\n| --- | --- |\n| 网卡模式 | NAT |\n| CPU核心数 | 2 |\n| 内存 | 2G |\n### 基本安装\n安装`docker`\n```\n// 安装docker\n$ yum install -y docker-ce\n// 开机启动 && 启动服务\n$ systemctl enable docker && systemctl start docker\n```\n安装镜像\n> google 镜像并不在docker库中，因此要防止墙的问题，需要找代替镜像\n```\n// 查看kubeadm镜像\n$ kubeadm config images list\n\n// 结果\nk8s.gcr.io/kube-apiserver:v1.13.3\nk8s.gcr.io/kube-controller-manager:v1.13.3\nk8s.gcr.io/kube-scheduler:v1.13.3\nk8s.gcr.io/kube-proxy:v1.13.3\nk8s.gcr.io/pause:3.1\nk8s.gcr.io/etcd:3.2.24\nk8s.gcr.io/coredns:1.2.6\n\n// 执行如下脚本（没有翻墙的同学只能通过阿里云镜像或者其他镜像）\n$ for i in `kubeadm config images list`; do \n  imageName=${i#k8s.gcr.io/}\n  docker pull registry.aliyuncs.com/google_containers/$imageName\n  docker tag registry.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName\n  docker rmi registry.aliyuncs.com/google_containers/$imageName\ndone;\n\n// 开机启动 && 启动服务\n$ systemctl enable kubelet && systemctl start kubelet\n```\n\n### k8s集群初始化\n\n```\n// 安装命令\n$ kubeadm init\n```\n### 安装过程中遇到的问题\n```\n[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2\n\n// 解决：\n// 虚拟机修改配置\n```\n\n```\n[ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1\n\n// 解决：\n// 编辑配置\n$ vi /etc/sysctl.conf\n// 添加如下内容\nnet.bridge.bridge-nf-call-iptables = 1\n```\n\n```\n[ERROR Swap]: running with swap on is not supported. Please disable swap\n\n// 解决：\n// 禁用swap功能\nswapoff -a\n\n// 修改配置\n$ vi /etc/fstab\n# 注释如下内容\n# k8s need disabled\n# /dev/mapper/centos-swap swap                    swap    defaults        0 0\n```\n安装成功\n```\nYour Kubernetes master has initialized successfully!\n```\n### 安装完成后的配置\n```\n// 安装成功后根据提示配置\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n// master 参与工作（单机模式必备）\nkubectl taint nodes --all node-role.kubernetes.io/master-\n```\n> 这边有一个BUG遇到，实际服务器可能不存在，但是虚拟机使用NAT模式，并且网卡配置为dhcp模式，动态获取ip\n> 导致一些里问题\n> eg：coredns 启动失败\n> eg：kube-apiserver-localhost.localdomain 启动失败\n> 解决改为静态配置\n\n```\nBOOTPROTO=static\n\n// ...省略...\n\n# ip 为自己实际环境ip\nIPADDR=192.168.228.128\nGATEWAY=192.168.228.2\nNETMASK=255.255.255.0\nDNS1=8.8.8.8\nDNS2=114.114.114.114\n```\n查看k8s集群情况(现在只有system pod)\n```\n$ kubectl get pods --all-namespaces\n\n// 结果如下\nkube-system   coredns-86c58d9df4-48pxx                        1/1     Running   0          6m10s\nkube-system   coredns-86c58d9df4-wdlmr                        1/1     Running   0          6m10s\nkube-system   etcd-localhost.localdomain                      1/1     Running   0          5m22s\nkube-system   kube-apiserver-localhost.localdomain            1/1     Running   0          5m18s\nkube-system   kube-controller-manager-localhost.localdomain   1/1     Running   0          5m4s\nkube-system   kube-proxy-56m56                                1/1     Running   0          6m10s\nkube-system   kube-scheduler-localhost.localdomain            1/1     Running   0          5m18s\nkube-system   weave-net-585s5                                 2/2     Running   0          60s\n```\n开启单机模式\n```\n$kubectl taint nodes --all node-role.kubernetes.io/master-\n```\n\n查看master节点情况\n> 不要慌，这里`NotReady` 完全正常\n> 安装网卡插件后，查询即可变为`Ready`\n```\n$ kubectl get nodes\n// 结果\nlocalhost.localdomain   NotReady    master   144m   v1.13.3\n```\n\n安装网络插件\n```\n// 这边有很多选择，本次使用`weave`\n// 配置地址 https://kubernetes.io/docs/concepts/cluster-administration/addons/\n\n$ kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\"\n```\n\n开通必要端口号 防止不必要的问题出现\n```\n// 6443\nfirewall-cmd --zone=public --add-port=6443/tcp --permanent && firewall-cmd --reload\n// 10250\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent && firewall-cmd --reload\n```\n\n### 配置tomcat RC\n配置docker镜像\n```\n// 查看所需要镜像\ndocker search tomcat\n// 下载tag为tomcat的images（默认版本为lasted）\ndocker pull tomcat\n```\n\n> `replicas: 1` pod实例个数为1\n> `image: tomcat` docker镜像\n> `name: tomcat-demo` rc名称\n> `spec:template:` 当运行实例个数小于replicas时候，rc会根据spec:template: 自动生成对应个数pod\n```\napiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: tomcat-demo\nspec:\n  replicas: 1\n  selector:\n    app: tomcat-demo\n  template:\n    metadata:\n      labels:\n        app: tomcat-demo\n    spec:\n      containers:\n      - name: tomcat-demo\n        image: tomcat\n        ports:\n        - containerPort: 8080\n```\n运行配置并查看结果\n```\n// 运行yaml\n$ kubectl create -f tomcat-demo-rc.yaml\n// 结果如下\ntomcat-demo   NodePort    10.105.57.5   <none>        8080:30001/TCP   14s\n```\n\n### 配置tomcat service\n\n> `nodePort: 30001` 映射端口8080:30001\n> `name: tomcat-demo` 服务名\n\n`tomcat-demo-svc.yaml`配置文件内容\n```\napiVersion: v1\nkind: Service\nmetadata:\n  name: tomcat-demo\nspec:\n  type: NodePort\n  ports:\n   - port: 8080\n     nodePort: 30001\n  selector:\n    app: tomcat-demo\n```\n运行配置并查看结果\n```\n// 运行yaml\n$ kubectl create -f tomcat-demo-svc.yaml\n// 结果如下\ntomcat-demo   NodePort    10.105.57.5   <none>        8080:30001/TCP   14s\n```\n> `注意` svc与rc文件可以写在同一个yaml中\n开通端口号\n```\n$ firewall-cmd --zone=public --add-port=30001/tcp --permanent && firewall-cmd --reload\n```\n\n### 查看战果\n\n浏览器中查看结果 `http://${ip地址}:30001/`\n\n### 总结\n\n> 安装过生中遇到不少坑，但是都都克服了，最后加入tomcat环节我觉得很有必要，作为初学者，很多文章，都在讲“k8s集群”， 各种集群部署文章，跟着流程安装了一圈，对错与否都模棱两可，还是需要一个“可视化的结果”\n\n\n"}}]);